import { GoogleGenerativeAI } from "@google/generative-ai";
import { PERSONAS, PersonaId } from "./personas";
import { getActiveModel } from "./voice-training-service";
import { verifyConstraints } from "./constraint-service";

/**
 * GENERATED ASSETS SCHEMA
 * -----------------------
 * Represents the structured specific output generated by the AI.
 */
export interface GeneratedAssets {
  /** The main LinkedIn text post content (filtered & formatted). */
  textPost: string;
  /** Detailed prompt for image generation (Visualize Value style). */
  imagePrompt: string;
  /** 60-second video script for vertical video content. */
  videoScript: string;
  /** Voice note script optimized for audio delivery. */
  audioScript?: string;
  /** Optional URL of the generated image (if image generation was successful). */
  imageUrl?: string;
}

/**
 * CORE GENERATION FUNCTION
 * ------------------------
 * Orchestrates the text generation process using Google Gemini.
 * 
 * Flow:
 * 1. Selects the System Prompt based on `personaId`.
 * 2. Configures the Gemini Model (currently using `gemini-flash-latest`).
 * 3. Constructs the User Prompt with specific instructions.
 * 4. Calls the LLM and parses the JSON response.
 * 5. Validates the output against constraints (Length, Formatting).
 * 6. Retries automatically if validation fails.
 * 
 * @param input The raw user input (Topic or URL).
 * @param apiKey Google Gemini API Key.
 * @param personaId The selected persona (default: 'cso').
 */
export async function generateContent(
  input: string,
  apiKey: string,
  personaId: PersonaId = "cso"
): Promise<GeneratedAssets> {
  // MOCK MODE for Testing/Demo if key is 'demo'
  if (apiKey.toLowerCase().trim() === "demo") {
    await new Promise(r => setTimeout(r, 2000));
    const personaName = PERSONAS[personaId]?.name || "Unknown";
    return {
      textPost: `[MOCK ${personaName.toUpperCase()} OUTPUT]\n\nSuccess is about avoiding stupidity.\n\nMost people think they need to be smart.\n\nThey are wrong.\n\nYou just need to not be stupid.\n\n- Avoid ruin.\n- Survive long enough.\n- Let compounding work.\n\n(Generated by ${personaName})`,
      imagePrompt: "Minimalist vector line art. White on black. High contrast. A maze with one clear exit path.",
      videoScript: "HOOK: Stop trying to be smart. It's killing your gains.\n\nCUT TO: Black screen, white text 'AVOID STUPIDITY'.\n\nVO: In a world of geniuses, the survivor wins."
    };
  }

  // MODEL PRIORITY: Try gemini-flash-latest first, fallback to gemini-1.5-flash on rate limit
  const PRIMARY_MODEL = "gemini-flash-latest";
  const FALLBACK_MODEL = "gemini-1.5-flash";
  
  let modelName = PRIMARY_MODEL;
  const persona = PERSONAS[personaId];
  let systemInstruction = (persona?.basePrompt || "") + "\n" + (persona?.jsonSchema || "");

  // Check if using custom voice with fine-tuned model
  if (personaId === "custom") {
    try {
      const activeModel = await getActiveModel();
      
      if (activeModel && activeModel.geminiModelId) {
        console.log(`Using custom voice model: ${activeModel.geminiModelId}`);
        // For tuned models, the model name is the tuned model resource name
        modelName = activeModel.geminiModelId;
        // Tuned models often have the system prompt baked in or we can provide one
        // Usually good to provide the persona context still
        systemInstruction = "You are a LinkedIn creator with a unique voice. Maintain this voice strictly.";
      } else {
        console.warn("Custom persona selected but no trained model found, falling back to base Gemini");
      }
    } catch (e) {
      console.warn("Failed to load custom voice model, falling back to Gemini:", e);
    }
  }

  const prompt = `
    Analyze this input and generate 3 assets:
    1. LinkedIn Text Post (following the rules).
    2. "Visualize Value" Image Prompt (Minimalist vector line art, white on black, geometric representation of the concept).
    3. 60s Video Script (Cinematic, viral hook, regular retention cuts).

    INPUT:
    "${input}"

    Ensure the response is valid JSON.
  `;

  // Helper function to attempt generation with a specific model
  async function attemptGeneration(useModel: string): Promise<GeneratedAssets | null> {
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ 
      model: useModel, 
      systemInstruction: systemInstruction 
    });

    let attempts = 0;
    const MAX_ATTEMPTS = 2;
    let currentPrompt = prompt;

    while (attempts <= MAX_ATTEMPTS) {
      attempts++;
      try {
        console.log(`[AI Service] Generation Attempt ${attempts} with ${useModel}...`);
        const result = await model.generateContent({
          contents: [{ role: "user", parts: [{ text: currentPrompt }] }],
          generationConfig: { responseMimeType: "application/json" }
        });

        const content = result.response.text();
        if (!content) throw new Error("No content generated");
        
        const parsed = JSON.parse(content);
        const textPost = parsed.textPost || parsed.text_post || "";

        // VERIFY CONSTRAINTS
        const validation = verifyConstraints(textPost);

        if (validation.valid) {
          console.log(`[AI Service] Constraint Check Passed ✅ (Model: ${useModel})`);
          return {
            textPost,
            imagePrompt: parsed.imagePrompt || parsed.image_prompt || "",
            videoScript: parsed.videoScript || parsed.video_script || "",
          };
        }

        console.warn(`[AI Service] Constraint Failed ❌: ${validation.reason}`);
        
        if (attempts <= MAX_ATTEMPTS) {
          currentPrompt += `\n\nCRITICAL SYSTEM ALERT: The previous output failed verification. \nREASON: ${validation.reason}\n\nFIX: Rewrite the hook to be shorter. Strict limit: 210 chars.`;
        } else {
          console.warn("[AI Service] Max attempts reached. Returning best effort.");
          return {
            textPost: `[CONSTRAINT FAILED] ${textPost}`,
            imagePrompt: parsed.imagePrompt || parsed.image_prompt || "",
            videoScript: parsed.videoScript || parsed.video_script || "",
          };
        }
      } catch (e: unknown) {
        const errorMessage = e instanceof Error ? e.message : "Unknown error";
        console.error(`[AI Service] Attempt ${attempts} Error with ${useModel}:`, e);
        
        // RATE LIMIT: Return null to trigger fallback to different model
        if (errorMessage.includes("429") || errorMessage.includes("Quota") || errorMessage.includes("quota")) {
          console.warn(`[AI Service] Rate limit hit on ${useModel}. Will try fallback model.`);
          return null; // Signal to try fallback
        }
        
        // NETWORK/SERVER ERRORS: Return backup content
        if (errorMessage.includes("503") || errorMessage.includes("500") || errorMessage.includes("fetch failed")) {
          console.warn("[AI Service] Network/Server Error. Switching to Backup Content.");
          return {
            textPost: `[BACKUP MODE: API BUSY]\n\nConsistency beats intensity.\n\nEveryone starts strong.\nFew finish.\n\nThe secret isn't a hack.\nIt's showing up when you don't want to.\n\nDon't break the chain.`,
            imagePrompt: "Minimalist vector lines showing a consistent upward trend vs erratic spikes. White on black.",
            videoScript: "HOOK: Why do 99% of people fail?\n\nCUT TO: Graph showing jagged spikes then a crash.\n\nVO: They rely on motivation.\n\nCUT TO: Straight rising line.\n\nVO: Winners rely on discipline.",
          };
        }

        if (attempts > MAX_ATTEMPTS) throw e;
      }
    }
    return null;
  }

  // TRY PRIMARY MODEL FIRST
  console.log(`[AI Service] Trying primary model: ${modelName}`);
  let result = await attemptGeneration(modelName);
  
  // IF RATE LIMITED, TRY FALLBACK MODEL
  if (result === null && modelName === PRIMARY_MODEL) {
    console.log(`[AI Service] Falling back to: ${FALLBACK_MODEL}`);
    result = await attemptGeneration(FALLBACK_MODEL);
  }
  
  if (result) {
    return result;
  }

  throw new Error("AI Generation failed after trying all models.");
}

/**
 * SIDE ASSET GENERATION
 * ---------------------
 * Generates secondary assets (Image Prompt, Video Script) based on the already generated text.
 * Used for the streaming workflow where we first stream text, then fill in the rest.
 */
export async function generateSideAssetsFromText(
  textPost: string,
  apiKey: string,
  personaId: PersonaId = "cso"
): Promise<Pick<GeneratedAssets, "imagePrompt" | "videoScript">> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ 
    model: "gemini-flash-latest",
    generationConfig: { responseMimeType: "application/json" }
  });

  const prompt = `
    Analyze this LinkedIn text post and generate the complementary assets:
    1. "Visualize Value" Image Prompt (Minimalist vector line art, white on black).
    2. 60s Video Script (Cinematic, viral hook).

    TEXT POST:
    """
    ${textPost}
    """

    Return JSON with keys: "imagePrompt", "videoScript".
  `;

  try {
    const result = await model.generateContent(prompt);
    const content = result.response.text();
    const parsed = JSON.parse(content);

    let videoScript = parsed.videoScript || parsed.video_script || "Script generation failed.";
    
    // Safety: If videoScript is an object (common with complex schemas), format it as readable string
    if (typeof videoScript === 'object') {
        // Use JSON.stringify with indentation for readable nested content
        videoScript = JSON.stringify(videoScript, null, 2)
            .replace(/[{}\[\]",]/g, '')  // Remove JSON syntax characters
            .split('\n')
            .filter(line => line.trim())  // Remove empty lines
            .map(line => line.trim())
            .join('\n');
    }

    return {
      imagePrompt: parsed.imagePrompt || parsed.image_prompt || "Minimalist geometric abstraction.",
      videoScript: String(videoScript),
    };
  } catch (e) {
    console.error("Side asset generation failed:", e);
    return {
      imagePrompt: "Error generating image prompt.",
      videoScript: "Error generating video script."
    };
  }
}
